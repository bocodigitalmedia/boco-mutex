// Generated by CoffeeScript 1.11.1
var Dependencies, configure,
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  slice = [].slice;

Dependencies = (function() {
  Dependencies.prototype.Error = null;

  Dependencies.prototype.EventEmitter = null;

  Dependencies.prototype.UUID = null;

  function Dependencies(props) {
    var key, val;
    for (key in props) {
      if (!hasProp.call(props, key)) continue;
      val = props[key];
      this[key] = val;
    }
    if (this.Error == null) {
      this.Error = (function() {
        try {
          return Error;
        } catch (error1) {}
      })();
    }
    if (this.EventEmitter == null) {
      this.EventEmitter = (function() {
        try {
          return require('events');
        } catch (error1) {}
      })();
    }
    if (this.UUID == null) {
      this.UUID = (function() {
        try {
          return require('uuid');
        } catch (error1) {}
      })();
    }
  }

  return Dependencies;

})();

configure = function(props) {
  var Error, EventEmitter, Exception, Lock, LockManager, LockRequest, LockRequestMismatch, LockRequestNotFound, NotLocked, ReleaseException, UUID, dependencies, ref;
  ref = dependencies = new Dependencies(props), Error = ref.Error, EventEmitter = ref.EventEmitter, UUID = ref.UUID;
  Exception = (function(superClass) {
    extend(Exception, superClass);

    Exception.getMessage = function(payload) {
      return null;
    };

    Exception.prototype.payload = null;

    function Exception(payload) {
      Exception.__super__.constructor.call(this);
      this.name = this.constructor.name;
      this.payload = payload;
      this.message = this.constructor.getMessage(payload);
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, this.constructor);
      }
    }

    return Exception;

  })(Error);
  ReleaseException = (function(superClass) {
    extend(ReleaseException, superClass);

    function ReleaseException() {
      return ReleaseException.__super__.constructor.apply(this, arguments);
    }

    ReleaseException.getMessage = function() {
      return "Cannot release.";
    };

    return ReleaseException;

  })(Exception);
  NotLocked = (function(superClass) {
    extend(NotLocked, superClass);

    function NotLocked() {
      return NotLocked.__super__.constructor.apply(this, arguments);
    }

    NotLocked.getMessage = function() {
      return "Cannot release, not currently locked.";
    };

    return NotLocked;

  })(ReleaseException);
  LockRequestMismatch = (function(superClass) {
    extend(LockRequestMismatch, superClass);

    function LockRequestMismatch() {
      return LockRequestMismatch.__super__.constructor.apply(this, arguments);
    }

    LockRequestMismatch.getMessage = function(arg) {
      var requestId;
      requestId = arg.requestId;
      return "Cannot release using LockRequest '" + requestId + "', not current LockRequest.";
    };

    return LockRequestMismatch;

  })(ReleaseException);
  LockRequestNotFound = (function(superClass) {
    extend(LockRequestNotFound, superClass);

    function LockRequestNotFound() {
      return LockRequestNotFound.__super__.constructor.apply(this, arguments);
    }

    LockRequestNotFound.getMessage = function(arg) {
      var requestId;
      requestId = arg.requestId;
      return "LockRequest not found: '" + requestId + "'.";
    };

    return LockRequestNotFound;

  })(ReleaseException);
  LockRequest = (function() {
    LockRequest.prototype.id = null;

    LockRequest.prototype.callback = null;

    LockRequest.prototype.releaseListener = null;

    LockRequest.prototype.lock = null;

    function LockRequest(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.id == null) {
        this.id = UUID();
      }
    }

    return LockRequest;

  })();
  Lock = (function() {
    Lock.prototype.locked = null;

    Lock.prototype.currentRequestId = null;

    Lock.prototype.emitter = null;

    Lock.prototype.requests = null;

    function Lock(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.locked == null) {
        this.locked = false;
      }
      if (this.currentKey == null) {
        this.currentKey = null;
      }
      if (this.emitter == null) {
        this.emitter = new EventEmitter;
      }
      if (this.requests == null) {
        this.requests = {};
      }
    }

    Lock.prototype.grantRequest = function(requestId) {
      var request;
      request = this.getRequest(requestId);
      this.locked = true;
      this.currentRequestId = requestId;
      return setImmediate((function(_this) {
        return function() {
          return request.callback(null, _this.release.bind(_this, requestId));
        };
      })(this));
    };

    Lock.prototype.attemptGrantRequest = function(requestId) {
      var request;
      if (!this.locked) {
        return this.grantRequest(requestId);
      }
      request = this.getRequest(requestId);
      request.releaseListener = (function(_this) {
        return function() {
          return _this.attemptGrantRequest(requestId);
        };
      })(this);
      return this.emitter.once('release', request.releaseListener);
    };

    Lock.prototype.hasRequest = function(requestId) {
      return this.requests[requestId] != null;
    };

    Lock.prototype.getRequest = function(requestId) {
      if (!this.hasRequest(requestId)) {
        throw new LockRequestNotFound({
          requestId: requestId
        });
      }
      return this.requests[requestId];
    };

    Lock.prototype.request = function(done) {
      var request;
      request = new LockRequest({
        callback: done,
        lock: this
      });
      this.requests[request.id] = request;
      this.attemptGrantRequest(request.id, done);
      return request;
    };

    Lock.prototype.release = function(requestId) {
      if (!this.locked) {
        throw new NotLocked;
      }
      if (requestId !== this.currentRequestId) {
        throw new LockRequestMismatch({
          requestId: requestId
        });
      }
      this.locked = false;
      this.currentRequestId = null;
      this.emitter.emit('release');
      return this.removeRequest(requestId);
    };

    Lock.prototype.removeRequest = function(requestId) {
      var listener;
      listener = this.getRequest(requestId).releaseListener;
      if (listener != null) {
        this.emitter.removeListener('release', listener);
      }
      return delete this.requests[requestId];
    };

    Lock.prototype.sync = function(work, done) {
      return this.request((function(_this) {
        return function(error, release) {
          if (error != null) {
            return done(error);
          }
          return work(function() {
            var error, results;
            error = arguments[0], results = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            done.apply(null, [error].concat(slice.call(results)));
            return release();
          });
        };
      })(this));
    };

    return Lock;

  })();
  LockManager = (function() {
    LockManager.prototype.locks = null;

    function LockManager(props) {
      var key, val;
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.locks == null) {
        this.locks = {};
      }
      if (this.Lock == null) {
        this.Lock = Lock;
      }
    }

    LockManager.prototype.construct = function() {
      return new this.Lock;
    };

    LockManager.prototype.get = function(id) {
      var base;
      return (base = this.locks)[id] != null ? base[id] : base[id] = this.construct();
    };

    return LockManager;

  })();
  return {
    configure: configure,
    dependencies: dependencies,
    Dependencies: Dependencies,
    Exception: Exception,
    ReleaseException: ReleaseException,
    NotLocked: NotLocked,
    LockRequestMismatch: LockRequestMismatch,
    LockRequestNotFound: LockRequestNotFound,
    Lock: Lock,
    LockManager: LockManager,
    LockRequest: LockRequest
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
